/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { BaseContract, BigNumberish, BytesLike, FunctionFragment, Result, Interface, EventFragment, AddressLike, ContractRunner, ContractMethod, Listener } from "ethers"
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedLogDescription, TypedListener, TypedContractMethod } from "./common.js"
  

  export interface MeterStoreInterface extends Interface {
    getFunction(nameOrSignature: "MAX_SEQUENCE_GAP" | "MAX_SUSPICIOUS_SCORE" | "MAX_TIMESTAMP_DRIFT" | "MIN_VERIFICATION_COUNT" | "consensus" | "emergencyPause" | "getLastSequence" | "getMeterStats" | "getReading" | "getReadingReasons" | "getVersion" | "idsService" | "lastSequences" | "meterRegistry" | "meterStats" | "owner" | "readingExists" | "readings" | "signatureUsed" | "storeReading" | "updateIDSService" | "verifyReading"): FunctionFragment;

    getEvent(nameOrSignatureOrTopic: "ConsensusReached" | "ReadingStored" | "ReadingVerified" | "SuspiciousReadingFlagged"): EventFragment;

    encodeFunctionData(functionFragment: 'MAX_SEQUENCE_GAP', values?: undefined): string;
encodeFunctionData(functionFragment: 'MAX_SUSPICIOUS_SCORE', values?: undefined): string;
encodeFunctionData(functionFragment: 'MAX_TIMESTAMP_DRIFT', values?: undefined): string;
encodeFunctionData(functionFragment: 'MIN_VERIFICATION_COUNT', values?: undefined): string;
encodeFunctionData(functionFragment: 'consensus', values?: undefined): string;
encodeFunctionData(functionFragment: 'emergencyPause', values?: undefined): string;
encodeFunctionData(functionFragment: 'getLastSequence', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'getMeterStats', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'getReading', values: [AddressLike, BigNumberish]): string;
encodeFunctionData(functionFragment: 'getReadingReasons', values: [AddressLike, BigNumberish]): string;
encodeFunctionData(functionFragment: 'getVersion', values?: undefined): string;
encodeFunctionData(functionFragment: 'idsService', values?: undefined): string;
encodeFunctionData(functionFragment: 'lastSequences', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'meterRegistry', values?: undefined): string;
encodeFunctionData(functionFragment: 'meterStats', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
encodeFunctionData(functionFragment: 'readingExists', values: [AddressLike, BigNumberish]): string;
encodeFunctionData(functionFragment: 'readings', values: [AddressLike, BigNumberish]): string;
encodeFunctionData(functionFragment: 'signatureUsed', values: [BytesLike]): string;
encodeFunctionData(functionFragment: 'storeReading', values: [AddressLike, BigNumberish, BigNumberish, BigNumberish, BytesLike, BigNumberish, string[]]): string;
encodeFunctionData(functionFragment: 'updateIDSService', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'verifyReading', values: [AddressLike, BigNumberish, boolean]): string;

    decodeFunctionResult(functionFragment: 'MAX_SEQUENCE_GAP', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'MAX_SUSPICIOUS_SCORE', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'MAX_TIMESTAMP_DRIFT', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'MIN_VERIFICATION_COUNT', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'consensus', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'emergencyPause', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getLastSequence', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getMeterStats', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getReading', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getReadingReasons', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getVersion', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'idsService', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'lastSequences', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'meterRegistry', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'meterStats', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'readingExists', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'readings', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'signatureUsed', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'storeReading', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'updateIDSService', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'verifyReading', data: BytesLike): Result;
  }

  
    export namespace ConsensusReachedEvent {
      export type InputTuple = [meterId: AddressLike, sequence: BigNumberish, consensus: boolean, voteCount: BigNumberish];
      export type OutputTuple = [meterId: string, sequence: bigint, consensus: boolean, voteCount: bigint];
      export interface OutputObject {meterId: string, sequence: bigint, consensus: boolean, voteCount: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace ReadingStoredEvent {
      export type InputTuple = [meterId: AddressLike, sequence: BigNumberish, timestamp: BigNumberish, value: BigNumberish, signature: BytesLike, suspiciousScore: BigNumberish, verified: boolean, validator: AddressLike];
      export type OutputTuple = [meterId: string, sequence: bigint, timestamp: bigint, value: bigint, signature: string, suspiciousScore: bigint, verified: boolean, validator: string];
      export interface OutputObject {meterId: string, sequence: bigint, timestamp: bigint, value: bigint, signature: string, suspiciousScore: bigint, verified: boolean, validator: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace ReadingVerifiedEvent {
      export type InputTuple = [meterId: AddressLike, sequence: BigNumberish, verified: boolean, verifier: AddressLike];
      export type OutputTuple = [meterId: string, sequence: bigint, verified: boolean, verifier: string];
      export interface OutputObject {meterId: string, sequence: bigint, verified: boolean, verifier: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace SuspiciousReadingFlaggedEvent {
      export type InputTuple = [meterId: AddressLike, sequence: BigNumberish, suspiciousScore: BigNumberish, reasons: string[]];
      export type OutputTuple = [meterId: string, sequence: bigint, suspiciousScore: bigint, reasons: string[]];
      export interface OutputObject {meterId: string, sequence: bigint, suspiciousScore: bigint, reasons: string[] };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

  export interface MeterStore extends BaseContract {
    
    connect(runner?: ContractRunner | null): MeterStore;
    waitForDeployment(): Promise<this>;

    interface: MeterStoreInterface;

    
  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TypedEventLog<TCEvent>>>
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>
  
  once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>
  removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>


    
    
    MAX_SEQUENCE_GAP: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    MAX_SUSPICIOUS_SCORE: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    MAX_TIMESTAMP_DRIFT: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    MIN_VERIFICATION_COUNT: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    consensus: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    emergencyPause: TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >
    

    
    getLastSequence: TypedContractMethod<
      [meterId: AddressLike, ],
      [bigint],
      'view'
    >
    

    
    getMeterStats: TypedContractMethod<
      [meterId: AddressLike, ],
      [[bigint, bigint, bigint, bigint, bigint, bigint, bigint] & {totalReadings: bigint, verifiedReadings: bigint, suspiciousReadings: bigint, lastSequence: bigint, lastUpdate: bigint, averageValue: bigint, totalValue: bigint }],
      'view'
    >
    

    
    getReading: TypedContractMethod<
      [meterId: AddressLike, sequence: BigNumberish, ],
      [[bigint, bigint, string, bigint, boolean, boolean, string, bigint, bigint] & {timestamp: bigint, value: bigint, signature: string, suspiciousScore: bigint, verified: boolean, consensusReached: boolean, validator: string, blockNumber: bigint, verificationCount: bigint }],
      'view'
    >
    

    
    getReadingReasons: TypedContractMethod<
      [meterId: AddressLike, sequence: BigNumberish, ],
      [string[]],
      'view'
    >
    

    
    getVersion: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    idsService: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    lastSequences: TypedContractMethod<
      [arg0: AddressLike, ],
      [bigint],
      'view'
    >
    

    
    meterRegistry: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    meterStats: TypedContractMethod<
      [arg0: AddressLike, ],
      [[bigint, bigint, bigint, bigint, bigint, bigint, bigint] & {totalReadings: bigint, verifiedReadings: bigint, suspiciousReadings: bigint, lastSequence: bigint, lastUpdate: bigint, averageValue: bigint, totalValue: bigint }],
      'view'
    >
    

    
    owner: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    readingExists: TypedContractMethod<
      [meterId: AddressLike, sequence: BigNumberish, ],
      [boolean],
      'view'
    >
    

    
    readings: TypedContractMethod<
      [arg0: AddressLike, arg1: BigNumberish, ],
      [[bigint, bigint, bigint, string, bigint, boolean, boolean, string, bigint, bigint, bigint] & {sequence: bigint, timestamp: bigint, value: bigint, signature: string, suspiciousScore: bigint, verified: boolean, consensusReached: boolean, validator: string, blockNumber: bigint, gasUsed: bigint, verificationCount: bigint }],
      'view'
    >
    

    
    signatureUsed: TypedContractMethod<
      [arg0: BytesLike, ],
      [boolean],
      'view'
    >
    

    
    storeReading: TypedContractMethod<
      [meterId: AddressLike, sequence: BigNumberish, timestamp: BigNumberish, value: BigNumberish, signature: BytesLike, suspiciousScore: BigNumberish, reasons: string[], ],
      [boolean],
      'nonpayable'
    >
    

    
    updateIDSService: TypedContractMethod<
      [newIDS: AddressLike, ],
      [void],
      'nonpayable'
    >
    

    
    verifyReading: TypedContractMethod<
      [meterId: AddressLike, sequence: BigNumberish, verified: boolean, ],
      [void],
      'nonpayable'
    >
    


    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;

    getFunction(nameOrSignature: 'MAX_SEQUENCE_GAP'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'MAX_SUSPICIOUS_SCORE'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'MAX_TIMESTAMP_DRIFT'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'MIN_VERIFICATION_COUNT'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'consensus'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'emergencyPause'): TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'getLastSequence'): TypedContractMethod<
      [meterId: AddressLike, ],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'getMeterStats'): TypedContractMethod<
      [meterId: AddressLike, ],
      [[bigint, bigint, bigint, bigint, bigint, bigint, bigint] & {totalReadings: bigint, verifiedReadings: bigint, suspiciousReadings: bigint, lastSequence: bigint, lastUpdate: bigint, averageValue: bigint, totalValue: bigint }],
      'view'
    >;
getFunction(nameOrSignature: 'getReading'): TypedContractMethod<
      [meterId: AddressLike, sequence: BigNumberish, ],
      [[bigint, bigint, string, bigint, boolean, boolean, string, bigint, bigint] & {timestamp: bigint, value: bigint, signature: string, suspiciousScore: bigint, verified: boolean, consensusReached: boolean, validator: string, blockNumber: bigint, verificationCount: bigint }],
      'view'
    >;
getFunction(nameOrSignature: 'getReadingReasons'): TypedContractMethod<
      [meterId: AddressLike, sequence: BigNumberish, ],
      [string[]],
      'view'
    >;
getFunction(nameOrSignature: 'getVersion'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'idsService'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'lastSequences'): TypedContractMethod<
      [arg0: AddressLike, ],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'meterRegistry'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'meterStats'): TypedContractMethod<
      [arg0: AddressLike, ],
      [[bigint, bigint, bigint, bigint, bigint, bigint, bigint] & {totalReadings: bigint, verifiedReadings: bigint, suspiciousReadings: bigint, lastSequence: bigint, lastUpdate: bigint, averageValue: bigint, totalValue: bigint }],
      'view'
    >;
getFunction(nameOrSignature: 'owner'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'readingExists'): TypedContractMethod<
      [meterId: AddressLike, sequence: BigNumberish, ],
      [boolean],
      'view'
    >;
getFunction(nameOrSignature: 'readings'): TypedContractMethod<
      [arg0: AddressLike, arg1: BigNumberish, ],
      [[bigint, bigint, bigint, string, bigint, boolean, boolean, string, bigint, bigint, bigint] & {sequence: bigint, timestamp: bigint, value: bigint, signature: string, suspiciousScore: bigint, verified: boolean, consensusReached: boolean, validator: string, blockNumber: bigint, gasUsed: bigint, verificationCount: bigint }],
      'view'
    >;
getFunction(nameOrSignature: 'signatureUsed'): TypedContractMethod<
      [arg0: BytesLike, ],
      [boolean],
      'view'
    >;
getFunction(nameOrSignature: 'storeReading'): TypedContractMethod<
      [meterId: AddressLike, sequence: BigNumberish, timestamp: BigNumberish, value: BigNumberish, signature: BytesLike, suspiciousScore: BigNumberish, reasons: string[], ],
      [boolean],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'updateIDSService'): TypedContractMethod<
      [newIDS: AddressLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'verifyReading'): TypedContractMethod<
      [meterId: AddressLike, sequence: BigNumberish, verified: boolean, ],
      [void],
      'nonpayable'
    >;

    getEvent(key: 'ConsensusReached'): TypedContractEvent<ConsensusReachedEvent.InputTuple, ConsensusReachedEvent.OutputTuple, ConsensusReachedEvent.OutputObject>;
getEvent(key: 'ReadingStored'): TypedContractEvent<ReadingStoredEvent.InputTuple, ReadingStoredEvent.OutputTuple, ReadingStoredEvent.OutputObject>;
getEvent(key: 'ReadingVerified'): TypedContractEvent<ReadingVerifiedEvent.InputTuple, ReadingVerifiedEvent.OutputTuple, ReadingVerifiedEvent.OutputObject>;
getEvent(key: 'SuspiciousReadingFlagged'): TypedContractEvent<SuspiciousReadingFlaggedEvent.InputTuple, SuspiciousReadingFlaggedEvent.OutputTuple, SuspiciousReadingFlaggedEvent.OutputObject>;

    filters: {
      
      'ConsensusReached(address,uint256,bool,uint256)': TypedContractEvent<ConsensusReachedEvent.InputTuple, ConsensusReachedEvent.OutputTuple, ConsensusReachedEvent.OutputObject>;
      ConsensusReached: TypedContractEvent<ConsensusReachedEvent.InputTuple, ConsensusReachedEvent.OutputTuple, ConsensusReachedEvent.OutputObject>;
    

      'ReadingStored(address,uint256,uint256,uint256,bytes32,uint256,bool,address)': TypedContractEvent<ReadingStoredEvent.InputTuple, ReadingStoredEvent.OutputTuple, ReadingStoredEvent.OutputObject>;
      ReadingStored: TypedContractEvent<ReadingStoredEvent.InputTuple, ReadingStoredEvent.OutputTuple, ReadingStoredEvent.OutputObject>;
    

      'ReadingVerified(address,uint256,bool,address)': TypedContractEvent<ReadingVerifiedEvent.InputTuple, ReadingVerifiedEvent.OutputTuple, ReadingVerifiedEvent.OutputObject>;
      ReadingVerified: TypedContractEvent<ReadingVerifiedEvent.InputTuple, ReadingVerifiedEvent.OutputTuple, ReadingVerifiedEvent.OutputObject>;
    

      'SuspiciousReadingFlagged(address,uint256,uint256,string[])': TypedContractEvent<SuspiciousReadingFlaggedEvent.InputTuple, SuspiciousReadingFlaggedEvent.OutputTuple, SuspiciousReadingFlaggedEvent.OutputObject>;
      SuspiciousReadingFlagged: TypedContractEvent<SuspiciousReadingFlaggedEvent.InputTuple, SuspiciousReadingFlaggedEvent.OutputTuple, SuspiciousReadingFlaggedEvent.OutputObject>;
    
    };
  }